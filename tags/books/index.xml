<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>books on Hadooboo Dev Log</title>
        <link>https://hadooboo.github.io/tags/books/</link>
        <description>Recent content in books on Hadooboo Dev Log</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko-kr</language>
        <lastBuildDate>Fri, 04 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://hadooboo.github.io/tags/books/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>[개발 서적 공부] 객체지향의 사실과 오해를 읽고</title>
        <link>https://hadooboo.github.io/post/books/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4%EB%A5%BC-%EC%9D%BD%EA%B3%A0/</link>
        <pubDate>Fri, 04 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>https://hadooboo.github.io/post/books/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4%EB%A5%BC-%EC%9D%BD%EA%B3%A0/</guid>
        <description>&lt;h2 id=&#34;읽게-된-계기&#34;&gt;읽게 된 계기&lt;/h2&gt;
&lt;p&gt;웹 어플리케이션을 개발하면서 코드 퀄리티라는 문제를 종종 마주하게 된다. 코드를 예쁘게 짜는 것은 항상 쉽지 않다. 당연히 한 줄 한 줄도 중요하겠지만 전체적인 구조를 잡는 것도 매번 고민이 된다.&lt;/p&gt;
&lt;p&gt;3-tier application architecture, hexagonal architecture 등 다양한 아키텍처도 공부하고, 클린 코드 책을 읽으며 코드의 퀄리티를 높이는 방법도 공부해왔다. 그러나 그 모든 것의 기반에는 객체 지향 프로그래밍이라는 배경이 존재한다. 어떤 프로그래밍 언어를 쓰든 백엔드 서버를 구현하는 것은 항상 OOP 개념의 바운더리 안에 있었다. OOP라는 것에 대해서 확실한 개념이 있어야만 내가 만들고 있는 코드의 구조에 확신을 가지고 구현을 할 수 있을 것 같았다.&lt;/p&gt;
&lt;p&gt;나는 개인적으로 어떤 프레임워크든, 방법론이든 그 안에 담긴 철학을 보는 것을 좋아한다. 그것이 다른 객체지향 책도 많지만 이 책을 읽고자 선택하는 계기가 되었다. 대부분이 코드 없이 글이기 때문에 가볍게 고를 수 있었다.&lt;/p&gt;
&lt;h2 id=&#34;코드로써의-기록&#34;&gt;코드로써의 기록&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;기억에-남는-점&#34;&gt;기억에 남는 점&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;처음 golang으로 백엔드 서버 개발을 하기 시작하면서 상속도 없고, 클래스라는 개념도 없는 golang에서 객체지향 프로그래밍이 가능한 것인지 고민을 했던 적이 있다. 여러 블로그 글을 찾아 보아도 &amp;ldquo;최대한 객체지향스럽게 구현하기&amp;quot;와 같은 제목과 내용들이 전부였다.&lt;/p&gt;
&lt;p&gt;그러나 이 책을 읽고 내가 구문과 언어 규칙에 많이 매몰되어 있었다고 느꼈다. golang에는 클래스가 없을 뿐이지 struct는 있다. 인터페이스도 존재한다. 이런 최소한의 장치를 이용해서도 역할, 책임, 협력을 따르는 객체들과 그 상호작용을 프로그램 세계 안에 만들어낼 수 있다면 언어는 그걸로 충분히 역할을 다한 것이다. 객체지향을 잘 따르는 것은 언어의 책임이 아니라 코드를 구현하는 내 책임이다.&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;회사에서 개발을 하면서 성장하다보니 데이터베이스 중심 개발에 반기를 들었던 적이 있다. 팀에서 어떤 새로운 웹 어플리케이션을 개발하고자 할 때 가장 먼저 했던 것은 데이터베이스 스키마를 만드는 일이었다. 이런 프로세스는 어떻게 보면 간단하고 효율적이다. 공통으로 참조할 수 있는 스키마라는 명세가 있고, 그것을 쉽게 만들 수 있다는 것은 빠른 협업을 가능하게 하는 것 같았다.&lt;/p&gt;
&lt;p&gt;그러나 데이터베이스라는 도구는 웹 어플리케이션을 이루는 하나의 컴포넌트에 불과하다. 어떤 데이터를 영속적으로 저장하고자 할 때 데이터베이스를 이용하는데, 상황에 따라서 데이터는 메모리에 있기도, 캐시에 있기도, 파일 시스템에 있을 때도 있다. 우리 팀은 서비스의 본질이 아니라 편한 길을 택하고 있던 것이었다.&lt;/p&gt;
&lt;p&gt;데이터베이스 중심 개발의 문제는 반정규화 관련해서도 일어난다. 테이블에 로우가 쌓여 있을 때 그에 대한 통계를 내는 요구사항이 있다고 하자. 매번 합을 구하고 평균을 낼 수 없기 때문에 배치 방식을 통해서든, 다른 테이블을 통해서든 통계 정보를 누적 업데이트하는 흐름이 필요하다. 여기서 통계 정보를 저장하는 테이블을 만들었다고 하자. 이것은 객체인가? 독립된 객체라고 하기엔 통계를 낸 테이블에 너무 의존적이다. 그렇다고 기존 테이블과 하나의 객체로 묶기에는 테이블 하나당 객체 하나라고 생각했던 것과 모순적이다.&lt;/p&gt;
&lt;p&gt;이러한 문제는 데이터베이스를 RDB로 선정하면서 정규화하고 테이블을 쪼개고, 또는 합치고 하는 과정에서 객체가 분해되기 때문이다. 객체는 서비스 내에 존재하는 추상적인 개념이다. 그 개념을 데이터베이스에 저장할 때는 RDB의 입맛에 맞게, 가장 효율적으로 저장한다. 그 객체는 데이터베이스에서 불러질 때 동일한 객체로 다시 하나가 되어 서비스 내에서 동작한다.&lt;/p&gt;
&lt;p&gt;이 책을 읽고 위와 같은 논리로 데이터베이스 중심 설계에서 도메인 중심 설계로 넘어갔었던 경험이 떠올랐다. 이제는 타입을 우선 정의하고 객체들이 상호작용하다가 데이터를 영속적으로 저장하고자 할 때 데이터베이스를 이용한다. 데이터베이스는 도구이기 때문이다. 또한, 데이터 저장을 위해 사용할 도구를 RDB에 국한할 필요도 없어졌다. 요구사항에 맞춰 NoSQL, in-memory cache, FS 등을 자유롭게 사용하면 된다.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1, 2번은 내 경험과 관련된 기억에 남는 점이었다면 이제부터는 앞으로 개발자로써 어떻게 해야 할지에 대한 감상이라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;이 책은 단순히 디자인 패턴을 넘어 개발자가 개발을 어떻게 다뤄야 하는지에 대한 철학을 알려주는 책이라고 생각한다. 우리가 객체지향이라는 개념을 사용하면서 그 컨셉을 제대로 이해하고 구현하지 못하면 객체지향을 안쓰느니만 못한 코드가 만들어질 수 있다. 내가 이해한 객체지향 구현의 컨셉은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만들고 싶은 세계를 먼저 정리한다. 책에서는 엘리스가 들어간 이상한 나라라는 세계가 있었고, 카페라는 세계의 예시를 계속해서 들어 준다. 게시판을 구현한다면 게시판이라는 세계가 있는 것이다. 그리고 각 세계에서 일어났으면 하는 일들이 있을 것이다. 이를 정리한다.&lt;/li&gt;
&lt;li&gt;만든 세계가 객체 지도로 정리되어야 한다. 지도는 각 건물, 각 위치에 대한 정보를 자세하게 서술하는 것이 아니라 그들을 연결하는 방법과 전체적인 지형을 나타낸다. 이것은 다른 말로 하면 구조를 설계하는 일이다. 이 구조는 만든 세계의 뼈대가 되어 유지보수와 기능 추가라는 외부의 영향에도 안정적으로 유지되어야 한다. 객체 지도를 만든다는 것은 객체 간의 협력을 생각하며 역할과 역할 사이에서 어떤 메세지가 주고받아질지 정리하는 과정이다. 협력을 생각하면 당연히 어떤 역할이 어떤 책임들을 수행해야 할지도 자연스럽게 정리될 것이다.&lt;/li&gt;
&lt;li&gt;마지막으로 이 객체 지도를 코드의 세계로 옮겨야 한다. 협력은 메세지가 된다. 역할은 인터페이스가 된다. 책임은 메소드가 된다. 메세지, 인터페이스, 메소드를 통해 코드 세계를 추상적으로 구현할 수 있다. 각 요소에 대한 구체적인 구현은 최종 개발자에게 맡긴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다시 한 번 정리하면, 개발자는 생각을 먼저 해야 하고, 구조를 먼저 설계해야 하고, 그 다음에 그 세계를 코드로 옮기기 시작해야 한다. 구조를 충분히 아름답게 만드는 순간 그에 대응하는 코드는 자연스럽게 연동되게 되어 있다. 책의 구조도 그렇다. 1~6장까지 객체지향이라는 세계를 자세히 설명하고 7장에서 한 호흡으로 구현을 마무리한다. 앞으로의 개발 프로세스도 이같이 진행해야 하겠다.&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 책은 코드 관점에서만 객체지향을 얘기한다. 객체지향이라는 것 자체가 프로그래밍 방법론이기 때문이다. 그러나 과연 코드 레벨에서만 이같은 관점이 적용될까? 나는 어플리케이션 서비스의 구조적인 관점에서도 이와 같은 방법론이 적용된다고 생각한다. 2번에서 언급했듯이 데이터베이스라는 역할, API 서버라는 역할 그리고 그 사이의 협력이 존재하고, 역할을 수행할 수 있다면 API 서버는 자바로도, golang으로도, 파이썬으로도 구현할 수 있으며 데이터베이스도 마찬가지이다.&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;좋은 책이지만 아쉬운 점도 하나 있었다. 바로 동어반복이 너무나도 많다는 것이었다. 당연히 중요한 내용들이니만큼 계속해서 언급하고 헷갈리지 않게 하는 것이 중요하겠지만 각 장을 마주하면서 똑같은 글을 계속해서 반복해서 읽고 있다는 생각을 지울 수 없었다.&lt;/p&gt;
&lt;h2 id=&#34;책-정보&#34;&gt;책 정보&lt;/h2&gt;
&lt;p&gt;조영호. 객체지향의 사실과 오해 - 역할, 책임, 협력 관점에서 본 객체지향. 위키북스, 2015.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[개발 서적 공부] Go를 활용한 머신 러닝을 읽고</title>
        <link>https://hadooboo.github.io/post/books/go%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A8%B8%EC%8B%A0-%EB%9F%AC%EB%8B%9D%EC%9D%84-%EC%9D%BD%EA%B3%A0/</link>
        <pubDate>Fri, 16 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://hadooboo.github.io/post/books/go%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A8%B8%EC%8B%A0-%EB%9F%AC%EB%8B%9D%EC%9D%84-%EC%9D%BD%EA%B3%A0/</guid>
        <description>&lt;h2 id=&#34;읽게-된-계기&#34;&gt;읽게 된 계기&lt;/h2&gt;
&lt;p&gt;이제는 정말 머신러닝이라는 분야에 대해 알아가야 할 때가 온 것 같다. 정말 많은 자동화 기술들이 나오고 있고 copilot이라는 도구가 내 코드까지도 대신 짜 주는 현상을 보면 copilot이 어떻게 돌아가는지 아는 개발자만이 앞으로의 시대에서 살아남을 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;이 책은 원래부터 golang으로 머신러닝을 해보고 싶어서 구매한 것은 아니고 서점을 둘러보던 중 발견하여 신기함에 사 본 책이다. 머신러닝 분야는 전부 파이썬이 메인스트림으로 되어 있기 때문에 golang으로 하는 것은 본 적도 없고 들은 적도 없었다. 다만 내가 golang에 익숙하기 때문에 그 장점을 살려 머신러닝의 다른 측면을 볼 수 있지 않을까 하는 기대감에 공부하기 시작하였다.&lt;/p&gt;
&lt;h2 id=&#34;코드로써의-기록&#34;&gt;코드로써의 기록&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/hadooboo/ml-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/hadooboo/ml-go&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;기억에-남는-점&#34;&gt;기억에 남는 점&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;그냥 파이썬 쓰자&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;golang으로 머신러닝을 할 수 있는 것처럼 책을 호기롭게 시작했지만 결국에는 교과서에 나올 만한 몇 개의 기초적인 모델을 구현해보는 수준에 그쳤고, 더 발전된 모델이나 커스터마이징은 불가능한 수준이었다. 19년에 나온 책이라서 단순히 오래되었기 때문이라고 생각할 수도 있지만, pkg.go.dev 에서 최신 패키지들을 살펴보아도 그 동안 많은 진전이 있었던 것 같지는 않다. 그에는 다양한 이유가 있을 것이다.&lt;/p&gt;
&lt;p&gt;golang이 머신러닝에 적합하지 않다고 느낀 가장 큰 지점은 인터랙티브한 사용의 불가능이다. 이번 프로젝트를 하면서는 gophernotes, gonb 패키지를 이용하여 최대한 jupyter notebook을 사용해보기는 했지만 어디까지나 안정적인 지원이 되지 않는 써드파티 라이브러리일 뿐이다. golang이 인터프리터 언어가 아닌 것이 근본적인 원인이다. 코드를 블록 단위로 실행하면서 결과를 확인하며 점진적으로 진행하는 것이 모델을 만드는 데 있어 빠르고 편리하다. 컴파일을 매번 하면서 결과를 어딘가에 기록해두며 진행하는 것은 비효율적이다. 이 점이 가장 발목을 잡는다.&lt;/p&gt;
&lt;p&gt;또한, golang은 강타입 언어이다. 이 책에서는 강타입으로 제한을 주는 것이 오히려 발생할 수 있는 여러 타입 문제들을 사전에 차단해준다고 한다. 그러나 나는 이 지점이 자유롭게 모델을 만들어보고 커스터마이징하는 데에 방해가 된다고 느꼈다. 뭔가를 다시 시도해보려면 그 동안 만들었던 변수와 메소드 인자 등의 타입을 다시 다 조정해야 한다. 자유로운 모델 로딩도 힘들다. 타입 문제를 해결하는 것은 모델을 다 만들고 서비스에 붙여 안정적인 서빙을 해야 할 때 고려하면 될 것이다. 일단 모델이라도 여러 번 실험하면서 빠르게 결과를 찾아가려면 파이썬으로 하는 것이 훨씬 마음이 편할 것 같다.&lt;/p&gt;
&lt;p&gt;마지막으로 사람들이 많이 쓰는 언어를 그냥 따라가는 것이 좋아 보인다. 당연히 새로 나오는 모델들이나 여러 레퍼런스들이 그 언어와 그 라이브러리 안에서 만들어지고 소비되기 때문이다. 파이썬은 머신러닝에 있어 강력한 생태계를 가지고 있다. golang이 갑자기 발전하여 머신러닝에 언어적 특성이 적합해진다 한들 이미 커뮤니티는 다 파이썬으로 모델을 만들고 실험하고 있다. 그것을 따라가는 것은 불가능할 것이다. golang은 golang에 맞는 다른 역할이 있다.&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;학습에는 의미가 없지 않았다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;지금까지는 golang을 머신러닝을 할 때 사용하지 않아야 할 이유들에 대해서만 설명했다. 그러나 이 책을 읽고 따라해보며 배운 것도 없지 않다. 그렇지 않았다면 책을 중간에 내려놓았을 것이다.&lt;/p&gt;
&lt;p&gt;중요한 것은 내가 실제 서비스를 위한 모델을 만드는 것이 아니라 배우는 과정이었다는 점이다. 파이썬 라이브러리들에서는 여러 abstraction method를 제공하여 어떻게 동작하는지도 모르고 acf, pacf 값을 사용하거나 신경망을 사용하거나 할 것이다. 그러나 이번 공부를 하는 목적은 단순히 라이브러리 API 문서를 보고 따라하는 것이 아니라 최소한의 원리라도 이해하는 것이었다. 그 목적을 달성하기에는 오히려 아직 구현체가 많이 없어서, 하나하나 타입과 절차를 생각하면서 코드를 만들어야 하는 언어의 특성 때문에 좋은 점이 있었다.&lt;/p&gt;
&lt;h2 id=&#34;책-정보&#34;&gt;책 정보&lt;/h2&gt;
&lt;p&gt;Daniel Whitenack. Go를 활용한 머신 러닝 - Go 프로그래밍 언어를 사용해 회귀분석, 분류, 클러스터링, 시계열 모델, 신경망 및 딥러닝 구현하기. 장세윤 옮김. 에이콘출판, 2019.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[개발 서적 공부] 밑바닥부터 만드는 컴퓨팅 시스템을 읽고</title>
        <link>https://hadooboo.github.io/post/books/%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%8C%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EC%9D%BD%EA%B3%A0/</link>
        <pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://hadooboo.github.io/post/books/%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%8C%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EC%9D%BD%EA%B3%A0/</guid>
        <description>&lt;h2 id=&#34;읽게-된-계기&#34;&gt;읽게 된 계기&lt;/h2&gt;
&lt;p&gt;2023년은 chatgpt의 등장으로 코더는 사라질 것이라는 전망이 대두되기 시작한 해이다. 컴퓨터공학을 전공한 사람으로서 단순 반복 작업이나 간단한 문제 풀기는 정말로 AI에게 맞기는 것이 더 낫다는 생각이 들 정도였다.&lt;/p&gt;
&lt;p&gt;이런 상황에서 오히려 쓸모없어보일 수도 있는 기초로 돌아가야겠다고 생각했다. 하드웨어 게이트 설계, 어셈블러, 컴파일러를 한 번 만들어보면서 컴퓨터에 대해 전체적으로 이해할 수 있는 시각을 기르는 것이 오히려 근본으로써 변함이 없지 않을까 생각하였다.&lt;/p&gt;
&lt;h2 id=&#34;코드로써의-기록&#34;&gt;코드로써의 기록&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/hadooboo/nand2tetris&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/hadooboo/nand2tetris&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;기억에-남는-점&#34;&gt;기억에 남는 점&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;모듈화 및 인터페이스화의 중요성&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 책에는 프로젝트가 12가지 있었다. 간단한 프로젝트도 있었지만 복잡하고 문제 사이즈가 큰 경우도 있었다. 그런데 책에서는 친절하게도 어떤 모듈들로 구성하면 좋을지, 각 모듈은 어떤 동작을 하기를 기대하는지, 그 기능에 맞춘 메소드의 형태가 어떻게 될 것인지 모두 기술해주었다.&lt;/p&gt;
&lt;p&gt;이렇게 모듈로 나누는 것은 문제를 작게 만들어준다. 인간은 뇌의 한계가 있기 때문에 큰 문제를 한번에 풀려고 하면 풀기 어려워진다. 문제를 작게 나누었을 때 각각의 문제를 풀어가면서 하나의 큰 문제를 해결해나가는 것이 효율적이라고 생각한다.&lt;/p&gt;
&lt;p&gt;symbol table, vm writer, parser 등등 모듈 하나하나의 인터페이스를 먼저 정의한 뒤 unimplemented 상태의 기능들을 구현하면서 소소한 성취감을 느낄 수 있었다. 또한, 헬퍼 모듈들이 모두 만들어지면 코어 로직을 작성하는 것은 상대적으로 많이 쉬운 일이었다.&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;컴파일 과정의 2단계 분리&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;본 책의 후반부 내용은 high-level 객체 지향 언어를 기계어로 번역하는 컴파일러를 만드는 것이다. 7~11장까지 이 내용이 나온다. 그런데 재미있는 점은 10~11장에서 high-level 언어를 중간 단계 코드로, 7~8장에서 중간 단계 코드를 기계어로 번역한다. 똑같은 일을 2번 하는 것이 아닌가.&lt;/p&gt;
&lt;p&gt;어떻게 보면 1번이랑 같은 말을 하게 될지도 모르겠다. 문제를 작게 나누는 것이 중요하다. 문제를 사람이 쉽게 풀게 하기 위해서도 필요하다. 책에 나와 있는 설명처럼 code transportability의 관점에서도 문제를 작게 나누는 것이 좋다. high-level 언어를 macos용 컴파일러, windows용 컴파일러 등등 하나하나 다 만들 수는 없는 노릇이다. 적당한 수준의 low-level 까지 번역해주는 컴파일러를 하나 만든 뒤 그 중간 단계 코드를 각각의 os에 맞게 번역해 주면 문제가 쉬워진다.&lt;/p&gt;
&lt;p&gt;본 프로젝트에서는 어차피 jack이라는 언어와 hack이라는 os만 존재하여 그 효용을 크게 누리지는 못하였다. 그러나 연습용 프로젝트라고 현실과 다른 방향으로 구성하기보다는 최대한 현실에서의 용례를 반영하려고 했다는 점이 마음에 들었다.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;컴파일러 그 자체&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;책의 내용을 회고해보면 1~6장은 상대적으로 쉬운 내용이었으나 7~12장은 어려웠다. 컴파일러라는 것을 만들어보지 않았던 것 때문일 수도 있겠고, 당연히 책 후반부로 갈수록 어려워지는 것은 당연할 수도 있다. 그러나 어려웠던 만큼 기억에는 더 남고 배운 점도 더 많았던 것 같다.&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;low-level에서의 효율성&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;12장의 OS 만들기 프로젝트를 하면서 곱셉, 나눗셈까지도 어떻게 하면 더 효율적으로 할 수 있을지 고민하면서, 알고리즘을 찾아가면서 기능을 구현하였다. 이것은 OS의 메소드들이 다른 어떤 프로그램들에서도 호출되고, 자주 사용되기 때문에 그렇다. 예를 들어, multiply 메소드도 n을 m번 더하는 나이브한 방식으로 만들지 않고 bit shift 개념을 이용하여 비트 수에 비례한 시간 복잡도를 가지도록 만들어야 한다. 또한, 2와 3 같이 작은 수를 곱하는 상황에서도 최대한 덧셈을 대신 사용하려고 하였다. 이렇게 low-level에서 하나의 명령어라도 줄여보고자 하는 것이 재미있었다.&lt;/p&gt;
&lt;h2 id=&#34;책-정보&#34;&gt;책 정보&lt;/h2&gt;
&lt;p&gt;Noam Nisan, Shimon Schocken. 밑바닥부터 만드는 컴퓨팅 시스템 - 불 논리부터 컴퓨터 아키텍처, 운영체제까지. 김진홍 옮김. 인사이트, 2019.&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
