---
layout: mil
date: 1643641200
title: legacy 코드 다루기
tag: 삼정데이타서비스
permalink: /mils/202202
---

이번 달 업무는 우리 팀이 2~3년 전에 만들어 두었던 서비스에다가 기능을 추가하는 작업이었다. 해당 서비스는 외부로 제공 중이었으며 사람들이 이미 사용하고 있었기에 신중한 업데이트가 필요했다. 그러나 가장 큰 문제는 서비스가 개발될 때 팀에서 근무했던 사원이 아무도 없어서 코드를 직접 보고 어떤 방향으로 구현했는지 직접 확인해야 한다는 것이었다. 말로만 듣던 legacy 코드 분석을 실제로 처음 경험해보는 순간이었다.

코드를 보면서 가장 크게 느낀 차이점은 모든 데이터 전달용 구조체를 types 패키지에 넣고 사용하는 방법이었다. 이렇게 하면 패키지끼리 구조체를 서로 참조할 때 생기는 import cycle을 없앨 수 있다는 장점이 있지만 types 패키지 없이는 전체 코드가 돌아가지 못해서 모듈화가 되지 않는 문제가 있다. 현재 우리 팀의 구현 스타일은 데이터베이스 레이어에 table 형식과 동일하게 생긴 entity 구조체를 만들어 데이터베이스 중심 설계를 하는 것이다. API 서버 레이어에서 데이터베이스 레이어로 데이터를 주고 받을 때는 entity 구조체 형식만을 따라야 한다. 각 방법의 장단점이 있겠지만 현재 팀의 구현 스타일을 버리고 다른 스타일으로 구현하는 것은 색다른 경험이었다.

또한, 큰 차이점은 기본적으로 go 버전이 다르다는 것이었다. go는 아직까지도 업데이트가 빠르게 진행되고 있는 언어라서 대략 6개월 단위로 새 버전이 나오는 것 같다. legacy 코드의 go 버전은 1.13이었고, 현재 최신 버전은 1.17이다. go 버전을 낮춰서 개발 환경을 세팅하기만 하면 컴파일 단계에서 문제를 다 체크해 주겠지만, 현재 사용하고 있는 메소드가 1.13 이후에 새로 생긴 것일 수도 있어서 이전에는 어떻게 사용했는지 한 번 더 찾아봐야 하는 문제는 있었다. 예를 들어 `io.ReadAll` 메소드를 잘 사용하고 있었는데 go 1.16부터 등장했다는 것을 처음 알았다. 대신에 `ioutil.ReadAll`을 사용해야 했다. `As of Go 1.16, this function simply calls io.ReadAll.` 와 같은 공식 문서의 설명을 다시 보게 되는 계기가 되었다. 또한, go embed 기능도 1.16부터 추가되었다고 한다. 이번 업무에서 실행 파일에 정적 파일을 포함시켜야 하는 부분이 있어서 go embed를 사용하려고 하였으나 없는 기능이라고 나왔다. 그래서 Dockerfile에서 go 1.17로 업데이트를 진행하게 되었는데, 하위 호환성을 제공하기 때문에 문제는 없었으나 실행 파일을 빌드하는 과정에서 패키지 의존성 관리를 하는 방법이 go modules로 바뀌어 Dockerfile을 일부 수정해야 했다.

이렇게 legacy 코드를 다루는 것은 생각치도 못한 곳에서 예외 상황을 마주하기 때문에 사람들이 하기 싫어하는 것 같다고 느꼈다. 또한, 기존 코드에서 마음에 들지 않는 곳이 있더라도 수정을 했다가 원래의 기능이 제대로 동작하지 않게 될 위험성 때문이나 전체 구조의 변경으로 이어질 경우의 비용 때문에 손을 쉽게 대지 못하게 되는 것 같다. 이를 보고 <실용주의 프로그래머>의 “깨진 창문을 내버려두지 말라"라는 원칙이 생각났다. 한 번 손을 잘못 된 코드를 나중에 유지보수 할 경우 legacy의 불완전함을 고치려고 하기 보다는 불완전한 코드에 순응하여 결국에 하향 평준화된 코드가 만들어진다는 것이다. 긴 수명을 가지는 코드를 만들 때는 나 뿐만이 아니라 이 코드를 다시 보게 될 사람까지도 생각해서 신중한 코드를 만들어내야겠다는 생각을 하게 된다.