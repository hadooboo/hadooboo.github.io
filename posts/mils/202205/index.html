<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>202205 | Asterisk와 새로운 프로토콜 | Hadooboo Dev Log</title>
<meta name="keywords" content="">
<meta name="description" content="이번 달에는 사설 전화 네트워크(PBX)의 대표적인 오픈 소스 소프트웨어인 Asterisk를 사용하여 통화 연결 관련된 업무를 하였다. 살아가면서 ARS를 많이 사용해보긴 했지만 어떻게 작동할지는 상상해 본 적도 없었고 내가 그것을 구현하게 될지는 더더욱 상상도 못했다. 현재 대부분의 서비스 플랫폼은 웹 또는 앱 서비스 기반이라고 생각하는데 개발이라고 했을 때 나도 모르게 전형적인 서버 클라이언트 모델에만 초점을 맞췄던 것 같다.
가장 신기했던 것은 지금까지는 들어보지도 못했던 SIP, RTP 등의 프로토콜들이었다. 먼저 SIP는 통화의 개시와 종료 등의 메타 정보를 위해 사용되는 프로토콜이다.">
<meta name="author" content="Hadooboo">
<link rel="canonical" href="https://hadooboo.github.io/posts/mils/202205/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hadooboo.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hadooboo.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hadooboo.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hadooboo.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://hadooboo.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="202205 | Asterisk와 새로운 프로토콜" />
<meta property="og:description" content="이번 달에는 사설 전화 네트워크(PBX)의 대표적인 오픈 소스 소프트웨어인 Asterisk를 사용하여 통화 연결 관련된 업무를 하였다. 살아가면서 ARS를 많이 사용해보긴 했지만 어떻게 작동할지는 상상해 본 적도 없었고 내가 그것을 구현하게 될지는 더더욱 상상도 못했다. 현재 대부분의 서비스 플랫폼은 웹 또는 앱 서비스 기반이라고 생각하는데 개발이라고 했을 때 나도 모르게 전형적인 서버 클라이언트 모델에만 초점을 맞췄던 것 같다.
가장 신기했던 것은 지금까지는 들어보지도 못했던 SIP, RTP 등의 프로토콜들이었다. 먼저 SIP는 통화의 개시와 종료 등의 메타 정보를 위해 사용되는 프로토콜이다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hadooboo.github.io/posts/mils/202205/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-31T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-31T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="202205 | Asterisk와 새로운 프로토콜"/>
<meta name="twitter:description" content="이번 달에는 사설 전화 네트워크(PBX)의 대표적인 오픈 소스 소프트웨어인 Asterisk를 사용하여 통화 연결 관련된 업무를 하였다. 살아가면서 ARS를 많이 사용해보긴 했지만 어떻게 작동할지는 상상해 본 적도 없었고 내가 그것을 구현하게 될지는 더더욱 상상도 못했다. 현재 대부분의 서비스 플랫폼은 웹 또는 앱 서비스 기반이라고 생각하는데 개발이라고 했을 때 나도 모르게 전형적인 서버 클라이언트 모델에만 초점을 맞췄던 것 같다.
가장 신기했던 것은 지금까지는 들어보지도 못했던 SIP, RTP 등의 프로토콜들이었다. 먼저 SIP는 통화의 개시와 종료 등의 메타 정보를 위해 사용되는 프로토콜이다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://hadooboo.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Mils",
      "item": "https://hadooboo.github.io/posts/mils/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "202205 | Asterisk와 새로운 프로토콜",
      "item": "https://hadooboo.github.io/posts/mils/202205/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "202205 | Asterisk와 새로운 프로토콜",
  "name": "202205 | Asterisk와 새로운 프로토콜",
  "description": "이번 달에는 사설 전화 네트워크(PBX)의 대표적인 오픈 소스 소프트웨어인 Asterisk를 사용하여 통화 연결 관련된 업무를 하였다. 살아가면서 ARS를 많이 사용해보긴 했지만 어떻게 작동할지는 상상해 본 적도 없었고 내가 그것을 구현하게 될지는 더더욱 상상도 못했다. 현재 대부분의 서비스 플랫폼은 웹 또는 앱 서비스 기반이라고 생각하는데 개발이라고 했을 때 나도 모르게 전형적인 서버 클라이언트 모델에만 초점을 맞췄던 것 같다.\n가장 신기했던 것은 지금까지는 들어보지도 못했던 SIP, RTP 등의 프로토콜들이었다. 먼저 SIP는 통화의 개시와 종료 등의 메타 정보를 위해 사용되는 프로토콜이다.",
  "keywords": [
    
  ],
  "articleBody": "이번 달에는 사설 전화 네트워크(PBX)의 대표적인 오픈 소스 소프트웨어인 Asterisk를 사용하여 통화 연결 관련된 업무를 하였다. 살아가면서 ARS를 많이 사용해보긴 했지만 어떻게 작동할지는 상상해 본 적도 없었고 내가 그것을 구현하게 될지는 더더욱 상상도 못했다. 현재 대부분의 서비스 플랫폼은 웹 또는 앱 서비스 기반이라고 생각하는데 개발이라고 했을 때 나도 모르게 전형적인 서버 클라이언트 모델에만 초점을 맞췄던 것 같다.\n가장 신기했던 것은 지금까지는 들어보지도 못했던 SIP, RTP 등의 프로토콜들이었다. 먼저 SIP는 통화의 개시와 종료 등의 메타 정보를 위해 사용되는 프로토콜이다. RTP는 실제 음성 데이터를 주고받기 위한 프로토콜이다. UDP를 기반으로 하여 오버헤드 없이 빠른 전송을 목표로 하였고 통화 예시에서 뿐만 아니라 스트리밍에서도 쓰인다고 한다. 마지막으로 DTMF라는 개념은 핸드폰 키패드에서 숫자를 눌렀을 때 전달되는 그 정보이다. Asterisk에서는 SIP에 담아서 안정적으로 보낼 수도 있고(out of band) RTP에 담아서 빠르게 보낼 수도 있는데(in band) RFC2833을 따라 RTP로 보내는 것이 일반적이라고는 한다.\nAsterisk는 독립적으로 동작하는 애플리케이션이지만 agi, ami, ari라는 세 개의 인터페이스 채널을 통해 추가적인 기능을 실행하는 코드와 상호작용하도록 만들 수 있다. 세 인터페이스 모두 c++, java, python, go 등 다양한 언어 플랫폼에서 모두 사용할 수 있다. 그 중 ari가 가장 마지막으로 등장하였는데, 웹소켓을 통해 Asterisk 애플리케이션의 이벤트를 구독하고 REST API를 이용해 Asterisk에 특정 동작을 요청할 수 있어서 둘 중 하나의 역할밖에 하지 못하는 agi, ami보다 발전된 형태이다. ari를 이용하여 데이터베이스에 저장된 정보를 이용해 통화를 다른 곳으로 돌리는 스크립트를 만들면 되었다.\n개발을 하면서 결국에는 프로토콜 단위는 추상화가 되어 있어서 내가 SIP를 쓰는지, RTP를 쓰는지, HTTP를 쓰는지에 대해서는 알지 못해도 되는 레벨에서 스크립트를 구현했다. REST API를 Asterisk 클라이언트 라이브러리에서 이미 메소드로 구현하여 제공하고, 그 요청을 보냈을 때 Asterisk 쪽에서 어떻게 처리하는지는 몰라도 스크립트는 구현이 가능했기 때문이다. 오히려 어려웠던 것은 REST API는 동기로 보낼 수 있지만, 그에 따라 웹소켓으로 오는 정보는 비동기이기 때문에 브릿지를 만들고 채널을 잇는 등의 작업에서 타이밍을 고려해야 할 것이 많았다는 점이다. 전화를 받기 전에 끊기, 전화를 받지 않아 타임아웃 되기 등 사용자의 유스케이스를 전부 고려하는 것이 더 복잡하다면 복잡했다.\n이런 상황에서 low level에 대한 지식이 어디까지 필요할까 다시 한 번 생각해보게 되었다. 물론 표면적으로는 네트워크 기반 지식이 없어도 이번 업무를 할 수 있었던 것은 맞다. 그러나 RTP가 UDP 기반이라는 내용을 봤을 때 단번에 이해가 된 것은 UDP라는 배경 지식을 가지고 있었기에 가능한 것이었다고 본다. 이번에 RTP라는 내용을 알아 두었기 때문에 나중에 WebRTC같은 개념을 보게 될 때 더 빠른 이해가 가능할 것이다. 하나하나의 작은 개념들이 모여 궁극적으로는 하나의 큰 개념을 이룰 것이기 때문에 소홀히 해도 될 것은 아무것도 없다고 생각한다. 또한, 프로토콜은 말 그대로 사람들이 정의해 놓은 규칙이기 때문에 새로 마주하는 것에 겁낼 필요가 전혀 없어 보인다. 복잡한 로직도 아니고 말 그대로 규칙일 뿐이다.\n",
  "wordCount" : "408",
  "inLanguage": "en",
  "datePublished": "2022-05-31T00:00:00Z",
  "dateModified": "2022-05-31T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Hadooboo"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hadooboo.github.io/posts/mils/202205/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Hadooboo Dev Log",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hadooboo.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hadooboo.github.io/" accesskey="h" title="Hadooboo Dev Log (Alt + H)">Hadooboo Dev Log</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hadooboo.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://hadooboo.github.io/tag/" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://hadooboo.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://hadooboo.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://hadooboo.github.io/posts/mils/">Mils</a></div>
    <h1 class="post-title">
      202205 | Asterisk와 새로운 프로토콜
    </h1>
    <div class="post-meta"><span title='2022-05-31 00:00:00 +0000 UTC'>2022-05-31</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Hadooboo

</div>
  </header> 
  <div class="post-content"><p>이번 달에는 사설 전화 네트워크(PBX)의 대표적인 오픈 소스 소프트웨어인 Asterisk를 사용하여 통화 연결 관련된 업무를 하였다. 살아가면서 ARS를 많이 사용해보긴 했지만 어떻게 작동할지는 상상해 본 적도 없었고 내가 그것을 구현하게 될지는 더더욱 상상도 못했다. 현재 대부분의 서비스 플랫폼은 웹 또는 앱 서비스 기반이라고 생각하는데 개발이라고 했을 때 나도 모르게 전형적인 서버 클라이언트 모델에만 초점을 맞췄던 것 같다.</p>
<p>가장 신기했던 것은 지금까지는 들어보지도 못했던 SIP, RTP 등의 프로토콜들이었다. 먼저 SIP는 통화의 개시와 종료 등의 메타 정보를 위해 사용되는 프로토콜이다. RTP는 실제 음성 데이터를 주고받기 위한 프로토콜이다. UDP를 기반으로 하여 오버헤드 없이 빠른 전송을 목표로 하였고 통화 예시에서 뿐만 아니라 스트리밍에서도 쓰인다고 한다. 마지막으로 DTMF라는 개념은 핸드폰 키패드에서 숫자를 눌렀을 때 전달되는 그 정보이다. Asterisk에서는 SIP에 담아서 안정적으로 보낼 수도 있고(out of band) RTP에 담아서 빠르게 보낼 수도 있는데(in band) RFC2833을 따라 RTP로 보내는 것이 일반적이라고는 한다.</p>
<p>Asterisk는 독립적으로 동작하는 애플리케이션이지만 agi, ami, ari라는 세 개의 인터페이스 채널을 통해 추가적인 기능을 실행하는 코드와 상호작용하도록 만들 수 있다. 세 인터페이스 모두 c++, java, python, go 등 다양한 언어 플랫폼에서 모두 사용할 수 있다. 그 중 ari가 가장 마지막으로 등장하였는데, 웹소켓을 통해 Asterisk 애플리케이션의 이벤트를 구독하고 REST API를 이용해 Asterisk에 특정 동작을 요청할 수 있어서 둘 중 하나의 역할밖에 하지 못하는 agi, ami보다 발전된 형태이다. ari를 이용하여 데이터베이스에 저장된 정보를 이용해 통화를 다른 곳으로 돌리는 스크립트를 만들면 되었다.</p>
<p>개발을 하면서 결국에는 프로토콜 단위는 추상화가 되어 있어서 내가 SIP를 쓰는지, RTP를 쓰는지, HTTP를 쓰는지에 대해서는 알지 못해도 되는 레벨에서 스크립트를 구현했다. REST API를 Asterisk 클라이언트 라이브러리에서 이미 메소드로 구현하여 제공하고, 그 요청을 보냈을 때 Asterisk 쪽에서 어떻게 처리하는지는 몰라도 스크립트는 구현이 가능했기 때문이다. 오히려 어려웠던 것은 REST API는 동기로 보낼 수 있지만, 그에 따라 웹소켓으로 오는 정보는 비동기이기 때문에 브릿지를 만들고 채널을 잇는 등의 작업에서 타이밍을 고려해야 할 것이 많았다는 점이다. 전화를 받기 전에 끊기, 전화를 받지 않아 타임아웃 되기 등 사용자의 유스케이스를 전부 고려하는 것이 더 복잡하다면 복잡했다.</p>
<p>이런 상황에서 low level에 대한 지식이 어디까지 필요할까 다시 한 번 생각해보게 되었다. 물론 표면적으로는 네트워크 기반 지식이 없어도 이번 업무를 할 수 있었던 것은 맞다. 그러나 RTP가 UDP 기반이라는 내용을 봤을 때 단번에 이해가 된 것은 UDP라는 배경 지식을 가지고 있었기에 가능한 것이었다고 본다. 이번에 RTP라는 내용을 알아 두었기 때문에 나중에 WebRTC같은 개념을 보게 될 때 더 빠른 이해가 가능할 것이다. 하나하나의 작은 개념들이 모여 궁극적으로는 하나의 큰 개념을 이룰 것이기 때문에 소홀히 해도 될 것은 아무것도 없다고 생각한다. 또한, 프로토콜은 말 그대로 사람들이 정의해 놓은 규칙이기 때문에 새로 마주하는 것에 겁낼 필요가 전혀 없어 보인다. 복잡한 로직도 아니고 말 그대로 규칙일 뿐이다.</p>


<script src="https://utteranc.es/client.js"
        repo="hadooboo/hadooboo.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hadooboo.github.io/">Hadooboo Dev Log</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
